PIXELVAULT (PVX) BLOCKCHAIN & DASHBOARD - END-TO-END BUILD BLUEPRINT
I. System Goal:
Create a private, zkSNARK-enabled blockchain (PixelVault) with a native token (PVX). Integrate this blockchain seamlessly with the existing Alpine.js/Tailwind frontend dashboard, ensuring all displayed features (wallet, staking, mining, governance, Thringlets, drops, explorer) are connected to functional backend logic and reflect real on-chain or simulated-but-realistic state.
II. Core Components & Technology Stack:
Blockchain Layer (Core Logic - Target: Rust)
Chain Type: Private, Sovereign Layer 1.
Token (PVX):
Symbol: PVX (Display often as μPVX for micro-units if needed)
Total Supply: 6,009,420,000 (Fixed, non-inflationary beyond initial distribution/rewards).
Decimals: 6 (or 18, decide and be consistent - let's assume 6 for μPVX display).
Consensus: Proof-of-Work (Fair Mining - Equalized rewards, target GTX 1660+/Aebox ASIC) initially. Future upgrade path to PoS/PoA possible via governance.
Privacy: Native zkSNARK support (Halo2/ZEXE stack). Transaction details (sender/receiver/amount) should be shieldable. MVP can simulate this privacy layer before full implementation.
Block Time: Target ~5-10 seconds (similar to XRP finality goal).
Smart Contracts: Not required for MVP, focus on native features. WASM support is a future goal.
Bridging: None for MVP. XRPL bridge is a future goal.
Storage: Use RocksDB or similar embedded KV store for chain state/ledger.
Backend Services Layer (API & Logic - Target: Node.js/Express or Rust/Axum)
Provides RESTful API endpoints for the frontend.
Handles business logic, interacts with the Blockchain Core (via RPC or direct library calls if monolithic).
Manages user sessions/authentication.
Runs background tasks (e.g., staking reward calculation, Thringlet state decay).
Includes wallet, chain, stake, governance, thringlet, drop, explorer, auth modules.
WebSocket Server (eventhub): Pushes real-time updates to the frontend (new blocks, TX confirmations, Thringlet changes, rewards).
Database Layer (Off-Chain Data)
Primary DB (e.g., PostgreSQL via NeonDB): Stores user accounts (if separate from wallet keys), session data, Thringlet metadata/ownership (NFT link), claimed drop records, governance proposal text/details. Drizzle ORM for interaction.
Cache (e.g., Redis/MemoryStore): Optional, for session management or caching frequent API calls.
Frontend Layer (Dashboard - Existing: Alpine.js/Tailwind)
UI Framework: Alpine.js for interactivity, Tailwind CSS for styling.
Pages: All pages (Splash, Manifesto, Warroom, Dropzone, YCATA, Thringlet, Terminal, Settings, Learning Center) must be present and navigable.
API Client: JavaScript functions (fetch or axios) to call backend API endpoints.
WebSocket Client: Listens to the eventhub for real-time updates and reflects changes in the UI dynamically.
Wallet Interaction: Handles key generation/import client-side (if browser wallet), signing transactions locally before sending to backend API. Never send private keys to the backend.
III. Feature Implementation & API Wiring:
(Map frontend elements from your Alpine.js dashboard to these backend functions)
Feature Area	Frontend Component(s)	Required Backend API Endpoint(s) (Method /path)	Core Logic Involved (Backend Modules)	Key Data Flow
Wallet	Warroom Wallet Panel, Send Modal, etc.	POST /api/wallet/create <br> POST /api/wallet/import <br> GET /api/wallet/balance/:address <br> POST /api/wallet/send <br> GET /api/wallet/history/:address	wallet, chain, crypto, db (for user association if needed)	Generate keys client-side -> Store encrypted -> Fetch balance -> Sign TX client-side -> Send signed TX to API -> API broadcasts -> Update history
Blockchain	Warroom Mining/Explorer Panels	GET /api/blockchain/status <br> GET /api/blockchain/block/:heightOrHash <br> GET /api/blockchain/tx/:txHash <br> POST /api/mining/start (simulated)	chain, mining, explorer, db (chain store)	Fetch status -> Display -> Scan blocks/txs -> Simulate mining start
Staking	Warroom Staking Panel, Stake Modal	GET /api/stake/pools <br> POST /api/stake/start <br> POST /api/stake/unstake <br> POST /api/stake/claim <br> GET /api/stake/status/:address	stake, wallet, chain, db (staking records)	Fetch pools -> User stakes -> API locks PVX -> Rewards calculated -> User claims -> API sends reward TX
Governance	Warroom Governance Panel	GET /api/governance/proposals <br> GET /api/governance/proposal/:id <br> POST /api/governance/propose <br> POST /api/governance/vote	governance, stake, wallet, db (proposals, votes)	Fetch proposals -> User votes -> API validates stake/power -> Records vote
Thringlets	Thringlet Page, Warroom (maybe summary)	GET /api/thringlet/owner/:address <br> GET /api/thringlet/state/:id <br> POST /api/thringlet/interact <br> POST /api/thringlet/mint (rare trigger)	thringlet (emotion engine), wallet, db (metadata), chain (NFT mint)	User interacts -> API updates emotion state -> State affects UI/gameplay -> Rare mint triggers NFT creation
Secret Drops	Dropzone Page, YCATA Modal, Terminal	GET /api/drop/available <br> POST /api/drop/claim/:dropId <br> POST /api/auth/verify-code (for YCATA access)	drop, auth, wallet, db (drop records)	Fetch available drops -> User claims -> API verifies eligibility -> Records claim
Learning Center	Learning Center Page	GET /api/learn/modules <br> GET /api/learn/progress/:address <br> POST /api/learn/complete/:moduleId	learning (game logic - can be simple), wallet, db (progress)	Fetch modules -> User plays (simulated) -> API records completion/score
Real-time	All relevant UI elements	WebSocket connection (/ws)	eventhub, all other modules pushing updates	Backend detects change (new block, TX confirm, reward) -> Pushes via WS -> Frontend updates UI
IV. Backend File Structure (Target: Rust - cargo new pixelvault_backend --lib)
pixelvault_backend/
├── Cargo.toml
└── src/
    ├── main.rs                 # API Server entry point (e.g., using Axum or Actix)
    ├── api/                    # API route handlers & request/response structs
    │   ├── mod.rs
    │   ├── wallet_routes.rs
    │   ├── stake_routes.rs
    │   ├── chain_routes.rs
    │   ├── governance_routes.rs
    │   ├── thringlet_routes.rs
    │   ├── drop_routes.rs
    │   └── learning_routes.rs
    ├── core/                   # Core blockchain logic
    │   ├── mod.rs
    │   ├── block.rs
    │   ├── transaction.rs
    │   ├── ledger.rs           # State management
    │   ├── consensus.rs        # PoW logic
    │   └── mining.rs           # Miner coordination/reward logic
    ├── wallet/                 # Wallet generation, signing
    │   ├── mod.rs
    │   ├── keys.rs
    │   └── address.rs
    ├── staking/                # Staking logic, reward calculation
    │   └── mod.rs
    ├── governance/             # Voting, proposals
    │   └── mod.rs
    ├── thringlet/              # Emotion engine, state management
    │   └── mod.rs
    ├── drops/                  # Drop logic, verification
    │   └── mod.rs
    ├── learning/               # Learning module logic
    │   └── mod.rs
    ├── db/                     # Database interaction (Postgres + RocksDB interfaces)
    │   ├── mod.rs
    │   ├── postgres_db.rs
    │   └── chain_db.rs
    ├── p2p/                    # Optional: Peer-to-peer networking stubs
    │   └── mod.rs
    ├── zk/                     # zkSNARK integration (Halo2/ZEXE)
    │   ├── mod.rs
    │   └── circuits.rs         # Circuit definitions
    ├── utils/                  # Common utilities
    │   ├── mod.rs
    │   ├── crypto.rs
    │   └── config.rs
    └── websocket/              # WebSocket event hub logic
        └── mod.rs
Use code with caution.
V. Security & Key Management:
Private Keys: NEVER stored on the server. Generated and managed client-side (browser localStorage with strong encryption or dedicated secure context). Signing happens client-side.
Encryption: Use argon2 or scrypt for password hashing to derive encryption keys for local storage. Use AES-GCM for encrypting sensitive local data.
API Authentication: Use JWT or session tokens for authenticated routes (e.g., staking, claiming, voting, proposing).
zkSNARKs: Implement for transaction privacy (shielded pool). Ensure prover/verifier logic is correctly integrated.
Rate Limiting: Apply to sensitive API endpoints.
VI. Deployment Considerations (Replit):
Backend: Deploy the Rust/Node.js backend as a Replit service. Configure environment variables (.env or Replit Secrets) for database connections, JWT secrets, etc.
Frontend: Can be served statically by the backend or deployed as a separate static Replit site pointing to the backend API URL.
Database: Use Replit's built-in PostgreSQL or connect to an external service like NeonDB. For the chain state, RocksDB might require a custom setup or a simpler file-based store initially.
Process Management: Use Procfile or Replit deployments to run the main API server and any necessary background workers (like the staking reward calculator).
VII. Instructions for Replit AI:
Initialize Project: Use the provided file structure as the target. Choose Rust (with Axum/Actix) or Node.js (with Express/TypeScript) as the primary backend language.
Implement Core Modules: Start with core/, wallet/, and db/ modules. Implement basic block structure, transaction format, wallet generation (Ed25519), and simple ledger state management (in-memory or basic file store first, then RocksDB).
Build API Endpoints: Create handlers in the api/ directory corresponding to the "Feature Implementation & API Wiring" table. Connect these handlers to the core logic modules. Start with /api/ping, /api/wallet/create, /api/wallet/balance/:address.
Frontend Connection: Assume the frontend (index.html with Alpine.js) will make fetch requests to these API endpoints. Ensure API responses are in JSON format as expected by the frontend simulation logic.
Simulate Complex Features: For zkSNARKs, advanced consensus, and P2P networking, create stub functions or modules initially that return mock success/data, clearly marked with // TODO: Implement real ZK logic etc. Focus on getting the data flow working first.
Database Setup: Configure connection to Replit PostgreSQL for off-chain data. Set up basic tables for users/wallets, staking records, Thringlet metadata.
Iterative Build: Implement features module by module, testing each API endpoint with curl or a similar tool before assuming frontend integration.
This blueprint provides a clear path from the current state to a fully wired, operational system adhering to the PVX specifications. Pass this to Replit AI.